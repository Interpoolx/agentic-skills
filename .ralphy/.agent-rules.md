# React + Cloudflare D1 + Hono + Drizzle Development Rules

## Code Quality
- Add JSDoc comments to all functions with clear parameter and return type descriptions
- Follow existing code style and architecture patterns

## D1 Database
- **Foreign Keys**: Always declare explicitly in `CREATE TABLE` statements
- **Transactions**: Never use `BEGIN TRANSACTION` or `COMMIT` - D1 handles automatically
- **Schema Changes**: Use migrations only, never manual edits
- **Testing Flow**: `npm run db:pull` (local) → test → `npm run db:push` (remote)
- **Circular Dependencies**: Avoid unless one FK is NULL or uses `ON DELETE SET NULL`

## Drizzle ORM
- Define schema changes in Drizzle schema files, generate migrations with `drizzle-kit`
- Use Drizzle queries instead of raw SQL where possible for type safety

## Hono API
- Leverage Hono's lightweight routing and middleware for D1 bindings
- Access D1 via `c.env.DB` in route handlers

## Restrictions
- Never use `--no-backup` in production
- Reserved prefixes (`_cf_`, `sqlite_`, `_`) are auto-excluded from sync

## AI Skills & Tools
- **Auto-detect needs**: Analyze the task and automatically use relevant skills (web search for docs/updates, code execution for testing, artifacts for UI components)
- **Drizzle/D1 queries**: Search official docs when uncertain about syntax or best practices
- **Hono patterns**: Reference Hono documentation for middleware, routing, and D1 integration examples
- **React components**: Create artifacts for new components; update existing ones iteratively
- **Verification**: Use code execution to validate SQL migrations or test Drizzle queries before suggesting

## Security & API Protection
- **Secrets**: Never expose API keys, database credentials, or tokens in code, logs, or responses
- **Rate Limiting**: Implement rate limiting on all public endpoints (use Hono middleware or Cloudflare Workers rate limiting)
- **RLS/Authorization**: Always verify user permissions before database operations; use Row Level Security patterns where applicable
- **Input Validation**: Sanitize and validate all inputs before queries to prevent SQL injection
- **CORS**: Configure strict CORS policies; whitelist only trusted origins
- **Anti-Scraping**: Add endpoint-specific rate limits, require authentication for sensitive data
- **Error Messages**: Never leak stack traces, query details, or internal paths in production errors


## Context Management
- **Reset when needed**: If conversation becomes too long or unfocused, ask to start a fresh context with updated requirements
- **Summarize progress**: Before reset, provide a concise summary of completed work and next steps
- **Essential only**: Keep only critical rules, current task scope, and recent code changes in active context

## AI Personas
- Load persona definitions from `.ralphy/personas.json` in the project root. When the user types `@personaName`:
- Read the corresponding persona's systemPrompt from the JSON
- Adopt that persona's expertise and behavior
- Respond according to that persona's guidelines
- Indicate active persona with: `[Active Persona: {name} {icon}]`
- Auto-detect personas by matching user input against the `triggers` array in each persona definition.

# Bash Guidelines

## IMPORTANT: Avoid commands that cause output buffering issues
- DO NOT pipe output through `head`, `tail`, `less`, or `more` when monitoring or checking command output
- DO NOT use `| head -n X` or `| tail -n X` to truncate output - these cause buffering problems
- Instead, let commands complete fully, or use `--max-lines` flags if the command supports them
- For log monitoring, prefer reading files directly rather than piping through filters

## When checking command output:
- Run commands directly without pipes when possible
- If you need to limit output, use command-specific flags (e.g., `git log -n 10` instead of `git log | head -10`)
- Avoid chained pipes that can cause output to buffer indefinitely